---
title: "LAEI River data"
author: "James Smith"
output: html_document
date: "`r format(Sys.time(), '%Y-%m%-%d %H%:%M')`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs") }) 
---

Load libraries

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# rmarkdown::render('river_and_berths.Rmd', encoding = 'html_document', output_dir = "docs")

rm(list=ls(all=TRUE))

knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(mapview)
library(leaflet)
library(tidyverse)
library(BAMMtools)
library(raster)
library(sp)
library(viridis)
library(rasterVis)
library(rgeos)
```

Load coordinate reference systems

```{r, echo=FALSE, message=FALSE, warning=FALSE}
latlong = "+init=epsg:4326"
ukgrid = "+init=epsg:27700"
google = "+init=epsg:3857"
```

Load rivers and berths shapefiles

```{r import data, echo=FALSE, message=FALSE, warning=FALSE}

berths <- st_read('shapefiles/Berths.shp', quiet = T) %>% st_set_crs(27700)
berths <- berths[-179,]


river  <- st_read('shapefiles/River Thames Outline.shp', quiet = T) %>% st_set_crs(27700)

```

Check the berths look ok

```{r berths_plot, echo=FALSE, message=FALSE, warning=FALSE}
mapview(berths, map.types = c("OpenStreetMap.BlackAndWhite")) %>% addFeatures(river)
```

Import the emissions from PLA and grid shapefile. Note that they are 'exact cut'.

```{r grid_emissions, echo=FALSE, message=FALSE, warning=FALSE}

# Emissions by exact cut, substance and vessel type
emissions                   <- read_csv('emissions/inventory_export_2016.csv', col_types = cols())
emissions                   <- emissions[emissions$LAEIPLAExt == 'LAEI',]
emissions                   <- emissions[,c('VesselType', 'Substance', 'CellID', 'Sailing_kg', 'AtBerth_kg')]
emissions$CellID            <- as.numeric(emissions$CellID)
names(emissions)            <- c('ship_type', 'pollutant', 'cellid', 'sailing', 'berth')
pollutants_we_want          <- c('PM', 'PM2.5', 'NOx')
emissions                   <- emissions[emissions$pollutant %in% pollutants_we_want,]

#Now get the grid by exact cut
grid                        <- st_read('grids/LAEIGridExtensionV2.gpkg', quiet = T)
grid                        <- grid[grid$LAEIPLAExt == 'LAEI',]
grid                        <- grid[,c('GRID_ID0', 'CellID')]
names(grid)                 <- c('gridid', 'cellid', 'geom')

# Link grid exact cut to eimssions exat cut
grid_emissions              <- merge(emissions, grid, by.x = 'cellid', by.y = 'cellid')

grid_emissions              <- st_set_geometry(grid_emissions, grid_emissions$geom)

plot(grid_emissions[grid_emissions$ship_type == 'Passenger' & grid_emissions$pollutant == 'N2O','sailing'])

rm(grid, emissions)

```

Import GPS data for one day and tag as berth or not

```{r import_ais_data, echo=F, message=F, warning=F}
# Now import one day of points from the processed AIS data (via Andrew)

load('gps/apr1_AIS_decoded.Rdata')
gps_data                <- data
rm(data)
coordinates(gps_data)   <- ~lon+lat
proj4string(gps_data)   <- CRS(latlong)
gps_data                <- spTransform(gps_data, CRS(ukgrid))
gps_data                <- st_as_sf(gps_data)
gps_data                <- gps_data %>% st_set_crs(27700)
gps_data                <- st_crop(gps_data, grid_emissions)

berths                  <- st_buffer(berths, 30)
gps_data                <- st_join(gps_data, berths, join = st_intersects)

gps_data                <- gps_data[,c('time', 'berth_name', 'geometry')]
names(gps_data)         <- c('time', 'berth', 'geometry')

gps_data$time           <- 1

```

Make a 10m grid covering the area

```{r}
blank_raster <- raster(ext = extent(grid_emissions),
                       crs = ukgrid,
                       res = 10,
                       vals = NULL)

```

Now let's just do NO2 and shipping. First how many GPS points are in each 10m grid square.

```{r}

gps_counts   <- rasterize(gps_data, blank_raster, field = 'time', fun=sum)

rm(blank_raster)
```

Now if we turn this 10m raster into points .... count how many points are in each emissions polygon ... and do some division?

```{r}

```










```{r}
pollutants <- unique(grid_emissions$Substance)



for (i in 1:length(pollutants)) {
  
  berth          <- rasterize(grid_emissions[grid_emissions$Substance == pollutants[i],], r, field = 'AtBerth_kg', fun=sum)
  names(berth)   <- paste0('berth_', pollutants[i])
  sailing        <- rasterize(grid_emissions[grid_emissions$Substance == pollutants[i],], r, field = 'Sailing_kg', fun=sum)
  names(sailing) <- paste0('sailing_', pollutants[i])
  
  if (i == 1) {emissions <- stack(berth, sailing)} else {emissions <- stack(emissions, berth)
                                                         emissions <- stack(emissions, sailing)}
  
}

rm(berth, sailing, r, grid_emissions, pollutants,i)
```

Plot of NO2 sailing emissions raster

```{r emissions_sailing_co_raster_plot, echo=F, message=F, warning=F}

plot(emissions[['sailing_N2O']])
plot(river, add=T)
  layer(sp.polygons(as(river, 'Spatial'), col ='red'))


```

Plot of NO2 berth emissions raster

```{r emissions_berth_co_raster_plot, echo=F, message=F, warning=F}

levelplot(emissions[['berth_N2O']],
          margin=F,
          col.regions=viridis,
          scales=list(draw=F)) + 
  layer(sp.polygons(as(river, 'Spatial'), col ='red'))


```

### Process GPS data

```{r make_10m_grid, echo=F, message=F, warning=F}
# Make a 10m x 10m grid covering the area of the river emissions.

new_grid                  <- raster(extent(emissions), res=10, crs = ukgrid)
values(new_grid)          <- NA

```




Count GPS points in each 10m grid square. Create two rasters, one for 'at berth' and one for sailing.

```{r, echo=F, message=F, warning=F}

gps_data$time       <- 1

berth_grid          <- rasterize(gps_data[!is.na(gps_data$berth_name),1], new_grid, fun=sum)
sailing_grid        <- rasterize(gps_data[is.na(gps_data$berth_name),1], new_grid, fun=sum)

names(berth_grid)   <- c('id', 'count')
names(sailing_grid) <- c('id', 'count')

```

Plot of 10m counted GPS sailing points

```{r sailing_gps_points, echo=F, message=F, warning=F}

levelplot(sailing_grid[['count']],
          margin=F,
          col.regions=viridis,
          scales=list(draw=F),
          xlim=c(535000,545000),
          ylim=c(177000,182000)) + 
  layer(sp.polygons(as(river, 'Spatial'), col ='red'))

```

Plot of 10m counted GPS berth points

```{r berth_gps_points, echo=F, message=F, warning=F}

levelplot(berth_grid[['count']],
          margin=F,
          col.regions=viridis,
          scales=list(draw=F),
          xlim=c(535000,545000),
          ylim=c(177000,182000)) + 
  layer(sp.polygons(as(river, 'Spatial'), col ='red'))

```

```{r aggregate_up_to_100m, echo=F, message=F, warning=F}
# Aggregate the 10m count up to 1000m so that we know the number of points in each 1000m cell

berth_1km_grid        <- aggregate(berth_grid,   fact = 100, fun=sum)
sailing_1km_grid      <- aggregate(sailing_grid, fact = 100, fun=sum)

```

```{r disagreggate_down_to_10m, echo=F, message=F, warning=F}
# Then take the resolution back to 10m but keeping the number of points in each 1000m 'block' the same

berth_ten_m_grid     <- disaggregate(berth_1km_grid,   fact = 100, fun = NA)
sailing_ten_m_grid   <- disaggregate(sailing_1km_grid, fact = 100, fun = NA)

```

Now divide the number of points in each 10m grid, by the number of points in the surrounding 1000m grid, to find out what percent of the 1000m emissions each 10m grid cell is allocated

```{r divide_10m_by_100m, echo=F, message=F, warning=F}

berth_grid    <- berth_grid   / berth_ten_m_grid
sailing_grid  <- sailing_grid / sailing_ten_m_grid

rm(gps_data, berth_1km_grid, sailing_1km_grid, new_grid, berth_ten_m_grid, sailing_ten_m_grid, grid)

names(berth_grid)   <- c('id','percent_of_100m_emissions')
names(sailing_grid) <- c('id','percent_of_100m_emissions')

```

### Results

So now have 'berth_grid' and 'sailing_grid' which are 10m cells, and in each cell is a number between 0 and 1, which is the percentage of the 100m cell emissions that belong to that cell. The emissions are a raster stack of 100m resolution. So 'pull down' to the 10m grid cell, the amount of emissions from the 1km grid cell, based on the GPS points in that cell divided by the GPS points in the 1km cell.

```{r pm25, echo=F, message=F, warning=F}

pm25_sailing_emissions        <- disaggregate(emissions[['sailing_PM2.5']], fact = 100, fun = NA)
pm25_sailing_emissions        <- pm25_sailing_emissions$sailing_PM2.5 * sailing_grid$percent_of_100m_emissions
names(pm25_sailing_emissions) <- 'sailing_pm25'
pm25_sailing_emissions_out    <- data.frame(rasterToPoints(pm25_sailing_emissions))
write.csv(pm25_sailing_emissions_out, 'results/pm25_sailing_emissions.csv', row.names = F)

pm25_berth_emissions          <- disaggregate(emissions[['berth_PM2.5']], fact = 100, fun = NA)
pm25_berth_emissions          <- pm25_berth_emissions$berth_PM2.5 * berth_grid$percent_of_100m_emissions
names(pm25_berth_emissions)   <- 'berth_pm25'
pm25_berth_emissions_out      <- data.frame(rasterToPoints(pm25_berth_emissions))
write.csv(pm25_berth_emissions_out, 'results/pm25_berth_emissions.csv', row.names = F)

```

Plot of 10m PM2.5 sailing emissions
```{r results_pm25_sailing_plot, echo=F, message=F, warning=F}

levelplot(pm25_sailing_emissions,
          margin=F,
          col.regions=viridis,
          scales=list(draw=F),
          xlim=c(535000,545000),
          ylim=c(177000,182000)) + 
  layer(sp.polygons(as(river, 'Spatial'), col ='red'))

```

Plot of 10m PM2.5 berth emissions
```{r results_pm25_berth_plot, echo=F, message=F, warning=F}

levelplot(pm25_berth_emissions,
          margin=F,
          col.regions=viridis,
          scales=list(draw=F),
          xlim=c(535000,545000),
          ylim=c(177000,182000)) + 
  layer(sp.polygons(as(river, 'Spatial'), col ='red'))

```